let f, g, h;

const compose = (...fns) => {
  return (x) => {
    for (let i = fns.length - 1; i >= 0; i--) {
      const fn = fns[i];
      x = fn(x);
    }
    return x;
  };
};

// 아래의 코드를 볼 때 우리의 시야는...
//        <----------------- 즉 오른쪽 부터 보게 됩니다.
h = (x) => compose(g, f)(x);

const 먹습니다 = (x) => x + " 먹습니다";
const 을 = (x) => x + "을";

// 언어적으로 표현하면 아래와 같습니다.
// 즉, 수학적 표현의 순서와 언어적 표현의 순서상 읽는 순서가 다릅니다.
compose(먹습니다, 을)("밥");

// 언어적 표현을 위한 함수를 정의하면...
// 아래의 함수는 compose와 함수 적용 순서가 반대가 됩니다.
const pipe = (...fns) => {
  return (x) => {
    for (const fn of fns) x = fn(x);
    return x;
  };
};

// 언어적 순서는 이제 아래와 같습니다.
//  (2)-------> <----(1) // 이 부분은 아직도... 거슬립니다.
pipe(을, 먹습니다)("밥");

/**
 * 인자 까지 고려하여 함수를 하나 더! 만들어 봅시다~
 * 첫번째 인자외에는 모두 함수로 간주하여,
 * pipe를 통해 함수를 정의하고, 정의 된 익멱함수에 첫번째 인자 x를 적용해줍니다.
 */
const go = (x, ...fns) => pipe(...fns)(x);

// ----------------> 자 드디어 우리는 보이는 데로,
// 해석이 가능하게 되었습니다!!!!
go("밥", 을, 먹습니다);
