// 수학 부터 시작하는 함수의 합성!!!!
let f, g, h;

/**
 * 여기서 집합 X를 정의역(domain),
 * Y를 공역(codomain)이라 말한다. 함수의 정의역과 공역을 강조하려면
 * f는 X에서 Y로의 함수(function from X to Y)이다'는 표현을 사용하고,
 * 보통 f:X→Y라는 표기가 이를 의미한다.
 *
 * 원소 x에 대응되는 원소를 x의 함숫값(value of the function)이라 하고,
 * f(x)라 표기한다.
 */

// 수학적인 내용은 복잡하지만 결과적으로는.... 아래와 같이 표현됨.
f = (x) => y;

/**
 * 함수에 대한 간단한 수학적 예시로는
 * 기울기가 2이고 y 절편이 3인 함수는...
 * 참고: images/graph1.jpg
 */

f = (x) => 2 * x + 3;

/**
 * 기울기가 5인 함수 g는...
 * 참고: images/graph2.png
 */
g = (x) => 5 * x;

/**
 * 자 그러면 본론으로 넘어가면.... 합성함수는 무엇인가?
 * 함수 h가 두 함수 f와 g의 연쇄로 나타내어질 때,
 * h를 f와 g의 합성함수라고 부르고,
 * 대개 h(x)=g(f(x)), #### h(x)=(g∘f)(x),
 * ####### 혹은 함수 자체를 다룰 때는 h=g∘f라고 쓴다. 계산 과정상 제일 안쪽(오른쪽) 함수부터 계산 과정이 진행된다.
 */

/**
 * 자 그러면 간단하게 f함수와 g함수를 연쇄(chain)하여,
 * h 함수를 정의해본다면 아래와 같이 정의 됩니다.
 * 참고: images/graph3.png
 */
h = (x) => g(f(x)); // 이것은 g∘f

/**
 * 여기서 주의할 점은....
 * f(g(x))와 g(f(x))는 다릅니다.
 * 참고: images/graph4.png
 */
h = (x) => f(g(x)); // 이것은 f∘g

/**
 * h(x) = (g∘f)(x)
 * ∘ <- 해당 키워드 f와 g를 연쇄가 되어 h를 정의로 대체 할 수 있습니다.
 * 즉 h = g∘f 으로 표현되며, ∘ 키워드의 적용 결과는 함수여야 합니다.
 *
 * 문제는 ∘ <- 해당 키워드는 javascript에는 존재하지 않는 키워드이기 때문에
 * h = compose(g, f) // ∘ <- 해당 키워드 대신 compose라는 함수를 만들어보면...
 * 아래와 같습니다.
 */

const compose = (...fns) => {
  return (x) => {
    for (let i = fns.length - 1; i >= 0; i--) {
      const fn = fns[i];
      x = fn(x);
    }
    return x;
  };
};

// compose를 적용하여 f와 g를 연쇄한 h함수를 정의 하면, 아래와 같이 표현 됩니다.
h = compose(g, f);
// 참고: images/graph3.png
h = (x) => compose(g, f)(x); // 이것은 g∘f

/**
 * 여기 까지가 함수합성에 대한 수학내용을 기반으로,
 * 함수합성을 구현한 코드입니다.
 */
