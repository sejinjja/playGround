/**
 * map / flatMap을 갖고 있다면, 저희는 Monad라고 부릅니다.
 * 
 * map만 있으면 functor
 * flatMap이 있으면 Monad
 * 자바스크립트에는 위의 조건을 만족하는 객체가 있습니다. Array!
 */
const 는 = (x) => x + "는";
const 귀엽습니다 = (x) => x + " 귀엽습니다";
const 치즈냥상자 = Array.of("치즈냥");
const 고양이상자 = Array.of(치즈냥상자);

// 이상함니다.... 생각해보니, Box 까지는 pipe / go를 사용했는데요???? 그냥 합성이 되네요?
const monad = Array.of(고양이상자).flatMap(는).flatMap(귀엽습니다);
monad.pop();

/**
 * 저는 사실 ES6에 map을 보고서는 왜 Map! 이지?
 * 왜 갑자기 열거형 기반의 자료구조에서 왜 딕셔너리기반의 자료구조! Map이 나오는거지?
 * 
 * 개인적으로는 별로였습니다.
 * 자 그러면 왜 map <- 인지 함수이름의 유래를 봅시다~ ㅎㅎㅎ
 */

////////////////////////////////////////////////////////////////////////

/**
 * 다시 수학 공부 입니다~
 * 
 * 범주론(Category theory)에서 함자(functor)는 두 범주를 연결하는 사상(mapping)으로,
 * 한 범주의 대상과 사상(mapping)을 다른 범주의 대상과 사상(mapping)으로 대응시킵니다.
 * 
 * 즉, 범주론(Category theory)적 관점에서 '함자(functor)'는 범주들 사이의 구조 보존 함수이며,
 * 이때 대응되는 대상들을 '사상(mapping)'이라고 부릅니다. 
 * 
 * 자, 일단위의 설명은 제껴두고~
 * 
 * 지구상에 모든 위도와 경도가 주어진다면, 지구본 상에 각 위도와 경도 맾핑해볼 수 있을 것 입니다.
 * -> 일단 이게 위의 내용입니다.
 * 
 * [지구상에 모든 위도와 경도](2차배열(문자열): 범주 A)가 주어진다면,
 * [지구본 상에 각 위도와 경도 점으로](그래프 혹은 다이어그램: 범주 B)
 * 매핑(함자 F: A → B)해볼 수 있을 것입니다.
 * 
 * 이때 범주 A 내부의 좌표들 간의 관계(예: 인접성, 거리 등)도 
 * 범주 B의 점들 간의 관계로 보존되는데, 이러한 관계를 사상(morphism := mapping)이라고 합니다.
 * 
 * 자!!!! 여기서 확인해야하는 건, 범주는 type이다! String / Number / Boolean .....
 */

////////////////////////////////////////////////////////////////////////////

/**
 * 자... 이제 pipe / go가 없어도 함수가 합성이 되는지 확인해봅시다!
 * 몇가지 수학법칙을 외웁시다~
 * 
 * 1. 각 대상 A에 대해 항등 사상(id_A)가 존재해야 합니다.
 *    이 사상은 A에서 A로 가는 사상입니다.
 * 
 * 2. 사상의 연속성: 사상 f: A -> B와 g: B -> C가 주어졌을 때, 이 두 사상의 합성 g ∘ f: A -> C가 존재해야 합니다.
 *    즉, 두 사상을 연결하여 하나의 사상으로 만들 수 있어야 합니다.
 * 
 * 3. 합성의 결합법칙: 세 개의 사상 f, g, h가 주어졌을 때, (h ∘ g) ∘ f = h ∘ (g ∘ f)가 성립해야 합니다.
 *    이것은 사상을 연결할 때 순서가 중요하지 않다는 것을 의미합니다.
 */

const A = 1; // 범주의 모임

// 1. 각 대상 A에 대해 항등 사상(id_A)가 존재해야 합니다.
const id_A = x => x
Array.of(A).map(id_A)[0] === A; // 매핑이 map 이므로

// 2. 사상의 연속성: 사상 f: A -> B와 g: B -> C가 주어졌을 때,
//    이 두 사상의 합성 g ∘ f: A -> C가 존재해야 합니다.
//    ❤️연결하여 하나의 사상으로 만들 수 있어야 합니다.❤️
const f = x => x + 1
const g = x => x * 2

const B = f(A) // A범주에 f를 매핑한 B범주
const C = g(B) // B범주에 g를 매핑한 C범주
g(f(A)) === C;
Array.of(A).map(f).map(g)[0] === C; // 매핑이 map 이므로

// 3. 합성의 결합법칙: 세 개의 사상 f, g, h가 주어졌을 때,
//    (h ∘ g) ∘ f = h ∘ (g ∘ f)가 성립해야 합니다.
//    (해석의 순서가 무조건 동일할 수 밖에 없기 때문에...)
//    ❤️연결하여 하나의 사상으로 만들 수 있어야 합니다.❤️
const h = x => x * 0;
Array.of(A).map(f).map(b => h(g(b)))[0] === Array.of(A).map(a => g(f(a))).map(h)[0]

// 왜 합성의 결합법칙인가???
// (h ∘ g) ∘ f = h ∘ (g ∘ f) = h ∘ g ∘ f = (h ∘ (g ∘ f))
// 즉! 저희는 몇번을 연속된 사상을 적용을 하던, 순차적으로 적용을 하던 동일한 값을 얻습니다. :)
Array.of(A).map(f).map(g).map(h)[0] === Array.of(A).map(a => h(g(f(a))))[0]

// =>>>> Box 까지는 pipe / go를 사용했는데요???? ❤️Functor를 이용하면~ 합성이 가능합니댜!❤️
